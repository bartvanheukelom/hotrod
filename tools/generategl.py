#!/usr/bin/python

import json
import re

#input output files
IN_FILE = '../bin/gen/glew_h.json'
OUT_FILE = '../bin/gen/gl.cpp.incl'

#map some OpenGL types to V8 types
unsigned = re.compile('unsigned|ubyte|ushort|uint|bitfield|boolean')
integer = re.compile('int|enum|sizei|short|byte')
double = re.compile('double|float|clampf|clampd')

EXCLUDE = re.compile('ATI|MESA')

def main():
    """Generates Gl bindings"""

    with open(IN_FILE, 'r') as f:
        data = f.read()
        json_in = json.loads(data)

    with open(OUT_FILE, 'w') as fout:

        w = lambda s: fout.write(s)
        wel = lambda: fout.write("\n")
        wl = lambda s: fout.write(s + "\n")

        wl("// generated by generategl.py - DON'T EDIT")
        wel()
        wel()
        wel()

        funcNames = []

        for func in json_in['functions']:

            #print(func)
            name = func['name']
            params = func['parameters']
            ret = func['return_type'];

            if ret != 'void': print(name + ": " + ret)

            if name in [
                "glCreateSyncFromCLeventARB"
            ]:
                print("SKIP " + name + " blacklisted")
                wl("// SKIP " + name + " blacklisted")
                wel()
                continue

            if ret in [
                "GLintptr",
                "GLsizeiptr",
                "GLvdpauSurfaceNV"
            ]:
                print("SKIP " + name + " for return type " + ret)
                wl("// SKIP " + name + " for return type " + ret)
                wel()
                continue

            if (re.search(EXCLUDE, name)):
                print("SKIP " + name)
                wl("// SKIP " + name)
                wel()
                continue

            for p in params:
                skip = False
                t = p['type']
                if (t.count('(') != 0 or t == 'GLLOGPROCREGAL' or t == 'GLDEBUGPROCAMD' or t == 'GLDEBUGPROCARB' or t == 'GLDEBUGPROC'):
                    print("SKIP " + name + " because it appears to have a function* param")
                    wl("// SKIP " + name)
                    wel()
                    skip = True
                    break
                p['type'] = p['type'].replace(' const*', '*')
            if (skip): continue

            funcNames.append(func)

            if not func['always']:
                wl("#ifdef " + name)
            wl("FUNCTION_SIGNATURE(" + name + ") {")
            first = True
            wl("\tFUNCTION_BODY_START(" + str(len(params)) + ")")

            # collect args
            for i, p in enumerate(params):
                t = p['type']
                ptr = 'Num'
                if t == 'GLsync': t = '__GLsync*'
                if t.endswith('**'):
                    t = t.replace('**', '*')
                    p['&'] = True
                if t.endswith('*'):
                    t = t.replace('*', '')
                    ptr = 'Ptr'

                if ptr == 'Num' and t.startswith('const '):
                    t = t.replace('const ', '')

                wl("\tauto a" + str(i) + " = get" + ptr + "Arg<" + t + ">(args[" + str(i) + "]); // " + p['full'])

            # call
            w("\t")
            if ret != 'void':
                w(ret + " r = ")
            w(name + "(")
            for i, p in enumerate(params):
                if (not first):
                    w(",")
                else:
                    first = False

                # TODO don't assume single element arrays but allow JS arrays
                if "&" in p:
                    w("&")
                w("a" + str(i))
            wl(");")
            if ret != 'void':
                wl("\tFUNCTION_BODY_RETURN(r)")
            wl("}")
            if not func['always']:
                wl("#endif")
            wel()

        wl("DECLARE_FUNCTIONS_START")
        for fn in funcNames:
            if not fn['always']:
                wl("#ifdef " + fn['name'])
            wl("\tDECLARE_FUNCTION(" + fn['name'] + ")")
            if not fn['always']:
                wl("#endif")
        wl("DECLARE_FUNCTIONS_END")

def multiple_replace(dict, text):
  """ Replace in 'text' all occurences of any key in the given
  dictionary by its corresponding value.  Returns the new string."""

  # Create a regular expression  from the dictionary keys
  regex = re.compile("(%s)" % "|".join(map(re.escape, dict.keys())))

  # For each match, look-up corresponding value in dictionary
  return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)

if __name__ == '__main__': main()
